<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniversalScanner</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Scanner PWA">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png"> 
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* TailwindCSS-Konfiguration */
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

        /* Zusätzliche Stile für spezifische Anforderungen */
        .highlight-green {
            background-color: #d4edda; /* Grün für scanned === quantity */
        }
        .highlight-orange {
            background-color: #fff3cd; /* Orange für scanned > quantity */
        }
        .feedback-error {
            color: #dc2626; /* Rot für Fehlermeldungen */
        }
        .feedback-success {
            color: #93c01f; /* Grün für Erfolgsmeldungen */
        }
        .loading-bar {
            height: 4px;
            background-color: #93c01f;
            animation: loading 2s linear infinite;
        }
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 100%; }
            100% { width: 0%; }
        }
        .modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0,0,0,0.5); 
            z-index: 50;
        }
        .modal-content { 
            background-color: white; 
            margin: 15% auto; 
            padding: 20px; 
            width: 70%; 
            max-width: 500px; 
            border-radius: 1rem; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .close { 
            color: #aaa; 
            float: right; 
            font-size: 28px; 
            font-weight: bold; 
            cursor: pointer; 
        }
        .close:hover { 
            color: #000; 
        }
        .registration-link a { 
            color: #93c01f; 
            text-decoration: underline; 
        }
        .scanned-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .scanned-controls button {
            background-color: #93c01f;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .scanned-controls button:hover {
            background-color: #7fa31a;
        }
        .scanned-controls span {
            min-width: 20px;
            text-align: center;
        }
        .editable-ean {
            cursor: text;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans text-gray-900">
    <div class="container mx-auto max-w-4xl p-6">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-4xl font-bold text-gray-900">UniversalScanner</h1>
            <button onclick="openSettingsModal()" class="py-2 px-4 bg-[#93c01f] text-white rounded-3xl text-sm font-semibold hover:bg-[#7fa31a] shadow-sm">Einstellungen</button>
        </div>

        <div class="mb-6 bg-white rounded-3xl shadow-sm p-6">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Lieferschein hochladen (PDF, Excel, CSV):</h3>
            <input type="file" id="deliveryNote" accept=".pdf,.xlsx,.xls,.csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-[#93c01f] file:text-white hover:file:bg-[#7fa31a]">
            <div id="loadingBar" class="hidden mt-2 loading-bar"></div>
        </div>

        <div class="mb-6 bg-white rounded-3xl shadow-sm p-6">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Daten extrahieren</h3>
            <label class="block text-sm font-medium text-gray-700 mb-2">EAN scannen:</label>
            <div class="flex space-x-4">
                <input type="text" id="eanInput" placeholder="EAN eingeben" class="flex-1 p-2 border border-gray-300 rounded-3xl text-sm focus:outline-none focus:ring-2 focus:ring-[#93c01f]">
                <button onclick="scanEAN()" class="py-2 px-4 bg-[#93c01f] text-white rounded-3xl text-sm font-semibold hover:bg-[#7fa31a] shadow-sm">Scannen</button>
            </div>
            <div class="mt-4">
                <button onclick="toggleEditEAN()" id="editEANButton" class="py-2 px-4 bg-gray-600 text-white rounded-3xl text-sm font-semibold hover:bg-gray-700 shadow-sm">EAN bearbeiten (Deaktiviert)</button>
            </div>
        </div>

        <div class="mb-6 bg-white rounded-3xl shadow-sm p-6">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Extrahierte Daten</h3>
            <div id="unknownEANs" class="mb-4 text-sm text-gray-700"></div>
            <table class="w-full border-collapse">
                <thead>
                    <tr class="bg-gray-200 text-gray-800 text-sm">
                        <th class="border border-gray-300 p-3 text-left">EAN</th>
                        <th class="border border-gray-300 p-3 text-left">Produkt</th>
                        <th class="border border-gray-300 p-3 text-left">Menge</th>
                        <th class="border border-gray-300 p-3 text-left">Gescannte EANs</th>
                        <th class="border border-gray-300 p-3 text-left">Details</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody"></tbody>
            </table>
        </div>

        <div class="mb-6 bg-white rounded-3xl shadow-sm p-6">
            <button onclick="exportToExcel()" class="py-2 px-4 bg-[#93c01f] text-white rounded-3xl text-sm font-semibold hover:bg-[#7fa31a] shadow-sm mr-4">Als Excel exportieren</button>
            <button onclick="exportToCSV()" class="py-2 px-4 bg-[#93c01f] text-white rounded-3xl text-sm font-semibold hover:bg-[#7fa31a] shadow-sm">Als CSV exportieren</button>
        </div>

        <div class="mb-6 hidden" id="uploadPrompt">
            <p class="text-sm text-gray-600">Lieferschein hochladen, um das Lager zu öffnen</p>
        </div>

        <div class="mb-6" id="feedbackMessage"></div>

        <div id="settingsModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeSettingsModal()">×</span>
                <h2 class="text-xl font-semibold text-gray-800 mb-4">API Einstellungen</h2>
                <label for="apiProvider" class="block text-sm font-medium text-gray-700 mb-2">API Anbieter auswählen:</label>
                <select id="apiProvider" onchange="updateApiEndpoint()" class="w-full p-2 border border-gray-300 rounded-3xl text-sm focus:outline-none focus:ring-2 focus:ring-[#93c01f] mb-4">
                    <option value="">-- Anbieter auswählen --</option>
                    <option value="groq">Groq AI (empfohlen)</option>
                    <option value="xai">xAI (Grok API)</option>
                    <option value="openai">OpenAI (ChatGPT API)</option>
                    <option value="anthropic">Anthropic (Claude API)</option>
                    <option value="huggingface">Hugging Face (Inference API)</option>
                </select>
                <p id="apiEndpointDisplay" class="text-sm text-gray-700 mb-2">API Endpoint: <span id="endpointUrl"></span></p>
                <p id="registrationLink" class="registration-link text-sm text-gray-700 mb-4"></p>
                <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-2">API Key:</label>
                <input type="text" id="apiKey" placeholder="API Key eingeben" class="w-full p-2 border border-gray-300 rounded-3xl text-sm focus:outline-none focus:ring-2 focus:ring-[#93c01f] mb-4">
                <button onclick="saveApiSettings()" class="py-2 px-4 bg-[#93c01f] text-white rounded-3xl text-sm font-semibold hover:bg-[#7fa31a] shadow-sm">Speichern</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script type="text/javascript">
        // Global variables for XLSX parsing (retained from original for compatibility)
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];

                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));

                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }

                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }

        // pdf.js Worker konfigurieren
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

        // API endpoint and registration link configurations
        const apiConfigs = {
            groq: {
                endpoint: 'https://api.groq.com/openai/v1/chat/completions',
                registration: 'https://console.groq.com/login'
            },
            xai: {
                endpoint: 'https://api.x.ai/v1/grok',
                registration: 'https://x.ai/api'
            },
            openai: {
                endpoint: 'https://api.openai.com/v1',
                registration: 'https://platform.openai.com/signup'
            },
            anthropic: {
                endpoint: 'https://api.anthropic.com/v1',
                registration: 'https://console.anthropic.com/login'
            },
            huggingface: {
                endpoint: 'https://api-inference.huggingface.co',
                registration: 'https://huggingface.co/join'
            }
        };

        // Load saved settings on page load
        let API_KEY = localStorage.getItem('apiKey') || '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';
        let API_ENDPOINT = localStorage.getItem('apiEndpoint') || 'https://api.groq.com/openai/v1/chat/completions';
        window.onload = function() {
            const savedProvider = localStorage.getItem('apiProvider');
            if (savedProvider) {
                document.getElementById('apiProvider').value = savedProvider;
                updateApiEndpoint();
            }
            if (localStorage.getItem('apiKey')) {
                document.getElementById('apiKey').value = localStorage.getItem('apiKey');
            }
            // Register Service Worker
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/sw.js')
                        .then(registration => {
                            console.log('Service Worker registriert mit Scope:', registration.scope);
                        })
                        .catch(error => {
                            console.error('Service Worker Registrierung fehlgeschlagen:', error);
                        });
                });
            }
        };

        function openSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function updateApiEndpoint() {
            const provider = document.getElementById('apiProvider').value;
            const config = apiConfigs[provider] || { endpoint: 'Kein Anbieter ausgewählt', registration: '' };
            document.getElementById('endpointUrl').textContent = config.endpoint;
            const registrationLink = document.getElementById('registrationLink');
            if (config.registration) {
                registrationLink.innerHTML = `Registrieren: <a href="${config.registration}" target="_blank">${config.registration}</a>`;
            } else {
                registrationLink.innerHTML = '';
            }
        }

        function saveApiSettings() {
            const provider = document.getElementById('apiProvider').value;
            const apiKey = document.getElementById('apiKey').value;
            if (provider && apiKey) {
                localStorage.setItem('apiProvider', provider);
                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('apiEndpoint', apiConfigs[provider].endpoint);
                API_KEY = apiKey;
                API_ENDPOINT = apiConfigs[provider].endpoint;
                displayFeedback('API Einstellungen gespeichert!', 'feedback-success');
                closeSettingsModal();
            } else {
                displayFeedback('Bitte wählen Sie einen Anbieter und geben Sie einen API Key ein.', 'feedback-error');
            }
        }

        function consolidateData(data) {
            const consolidatedMap = new Map();
            const noEanItems = [];

            data.forEach(item => {
                const ean = item.ean ? String(item.ean).trim() : '';
                if (ean) {
                    if (consolidatedMap.has(ean)) {
                        const existingItem = consolidatedMap.get(ean);
                        // Quantities can be strings with comma, parse them, add them, then convert back to string.
                        const currentQuantity = parseFloat(String(existingItem.quantity).replace(',', '.')) || 0;
                        const newQuantity = parseFloat(String(item.quantity).replace(',', '.')) || 0;
                        existingItem.quantity = String(currentQuantity + newQuantity);

                        // Merge details, avoiding duplicates. Use a clear separator.
                        if (item.details && String(item.details).trim() && !existingItem.details.includes(item.details)) {
                            existingItem.details += `; ${item.details}`;
                        }
                    } else {
                        consolidatedMap.set(ean, { ...item });
                    }
                } else {
                    noEanItems.push(item);
                }
            });
            return [...Array.from(consolidatedMap.values()), ...noEanItems];
        }

        let extractedData = [];
        let unknownEANs = [];
        let isEditingEAN = false; // Neuer Zustand für den Bearbeitungsmodus

        // Audio-Objekte für positive und negative Töne
        const positiveTone = new Audio('positive-tone.mp3'); // Ersetze durch tatsächliche MP3-Datei
        const negativeTone = new Audio('negative-tone.mp3'); // Ersetze durch tatsächliche MP3-Datei

        // Fallback: Synthetische Töne mit AudioContext
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playBeep(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Audio-Initialisierung nach Benutzerinteraktion
        document.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => console.log('AudioContext resumed'));
            }
        }, { once: true });

        // Enter-Tastenunterstützung für EAN-Eingabe
        document.getElementById('eanInput').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                scanEAN();
            }
        });

        document.getElementById('deliveryNote').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('uploadPrompt').classList.add('hidden');
                const loadingBar = document.getElementById('loadingBar');
                loadingBar.classList.remove('hidden');

                const fileType = file.name.split('.').pop().toLowerCase();
                try {
                    if (fileType === 'pdf') {
                        await analyzeDocument(file);
                    } else if (fileType === 'xlsx' || fileType === 'xls') {
                        await extractDataFromExcel(file);
                    } else if (fileType === 'csv') {
                        await extractDataFromCSV(file);
                    } else {
                        displayFeedback('Ungültiger Dateityp. Bitte laden Sie eine PDF-, Excel- oder CSV-Datei hoch.', 'feedback-error');
                    }
                } catch (error) {
                    console.error('Fehler beim Verarbeiten der Datei:', error);
                    displayFeedback(`Fehler beim Verarbeiten der Datei: ${error.message}`, 'feedback-error');
                } finally {
                    loadingBar.classList.add('hidden');
                }
            }
        });

        async function extractTextFromPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    text += content.items.map(item => item.str).join(' ') + '\n';
                }
                console.log('Extrahierter PDF-Text:', text);
                if (!text.trim()) {
                    throw new Error('Kein Text aus der PDF extrahiert.');
                }
                return text;
            } catch (error) {
                throw new Error(`PDF-Text-Extraktion fehlgeschlagen: ${error.message}`);
            }
        }

        async function extractDataFromExcel(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];

                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false });

                        if (jsonData.length === 0) {
                            extractedData = []; // Clear previous data
                            updateTable();
                            reject(new Error('Leere Excel-Datei.'));
                            return;
                        }

                        // --- Verbesserte Header-Erkennung ---
                        let headerRowIndex = -1;
                        let maxFilledCells = 0;
                        const MAX_HEADER_SCAN_ROWS = 25; // Max rows to check for header

                        for (let i = 0; i < Math.min(jsonData.length, MAX_HEADER_SCAN_ROWS); i++) {
                            const row = jsonData[i];
                            const filledCellsInRow = row.filter(cell => filledCell(cell)).length;
                            if (filledCellsInRow > maxFilledCells) {
                                maxFilledCells = filledCellsInRow;
                                headerRowIndex = i;
                            }
                        }

                        if (headerRowIndex === -1) {
                            extractedData = [];
                            updateTable();
                            reject(new Error('Keine sinnvolle Kopfzeile in der Excel-Datei gefunden.'));
                            return;
                        }

                        // Normalisiere Header-Namen
                        const rawHeaders = jsonData[headerRowIndex].map(h => String(h || '').trim());
                        const normalizedHeaders = rawHeaders.map(h => 
                            h.toLowerCase().replace(/[^a-z0-9]/g, '') // Nur alphanumerisch, Kleinbuchstaben
                        );

                        const dataRows = jsonData.slice(headerRowIndex + 1);

                        const mappedData = dataRows.map(row => {
                            const item = { ean: '', product: '', quantity: '0', details: [] };
                            let foundEAN = false;
                            let foundProduct = false;
                            let foundQuantity = false;

                            normalizedHeaders.forEach((normalizedHeader, index) => {
                                const value = row[index] !== undefined ? String(row[index]).trim() : '';

                                if ((normalizedHeader.includes('ean') || normalizedHeader.includes('barcode')) && !foundEAN) {
                                    item.ean = value;
                                    foundEAN = true;
                                } else if ((normalizedHeader.includes('produkt') || normalizedHeader.includes('bezeichnung') || normalizedHeader.includes('artikel')) && !foundProduct) {
                                    item.product = value;
                                    foundProduct = true;
                                } else if ((normalizedHeader.includes('menge') || normalizedHeader.includes('anzahl')) && !foundQuantity) {
                                    // Entferne nicht-numerische Zeichen für die Menge, aber erlaube Dezimalpunkte für potenzielle Mengen mit Nachkommastellen
                                    item.quantity = value.replace(/[^0-9.,]/g, '').replace(',', '.'); // Ersetze Komma durch Punkt für parseFloat
                                    // Validiere, ob es eine gültige Zahl ist, sonst Standardwert
                                    if (isNaN(parseFloat(item.quantity))) {
                                        item.quantity = '0';
                                    }
                                    foundQuantity = true;
                                } else if (value && value !== '' && !item.details.includes(`${rawHeaders[index]}: ${value}`)) {
                                    // Füge Details hinzu, aber nur, wenn nicht bereits eine Kerninformation
                                    // und wenn die Zelle nicht leer ist und die Information nicht redundant ist.
                                    item.details.push(`${rawHeaders[index]}: ${value}`);
                                }
                            });

                            // Ensure all required fields exist
                            item.ean = item.ean || '';
                            item.product = item.product || '';
                            item.quantity = item.quantity || '0'; // Sicherstellen, dass quantity immer ein String ist
                            item.details = item.details.join(', ');
                            item.scanned = 0;
                            return item;
                        }).filter(item => item.ean || item.product || parseInt(item.quantity) > 0); // Filter out rows that are entirely empty after mapping

                        extractedData = mappedData;
                        extractedData = consolidateData(extractedData);
                        console.log('Extracted Excel data:', extractedData);

                        if (!extractedData.length) {
                            displayFeedback('Keine relevanten Daten aus Excel extrahiert. Überprüfen Sie das Dateiformat, die Kopfzeilen (EAN, Produkt, Menge) und den Inhalt.', 'feedback-error');
                        } else {
                            displayFeedback(`Erfolgreich ${extractedData.length} Einträge aus Excel geladen.`, 'feedback-success');
                        }
                        updateTable();
                        resolve();
                    } catch (error) {
                        reject(new Error(`Fehler beim Parsen der Excel-Datei: ${error.message}`));
                    }
                };
                reader.onerror = (error) => reject(new Error(`Fehler beim Lesen der Excel-Datei: ${error}`));
                reader.readAsArrayBuffer(file);
            });
        }

        async function extractDataFromCSV(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        // Split lines, filter empty lines, handle different line endings
                        const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== '');

                        if (lines.length === 0) {
                            extractedData = []; // Clear previous data
                            updateTable();
                            reject(new Error('Leere CSV-Datei.'));
                            return;
                        }

                        // --- Verbesserte Header-Erkennung für CSV ---
                        let headerRowIndex = -1;
                        let maxFilledCells = 0;
                        const MAX_HEADER_SCAN_ROWS = 25; 
                        
                        // Temporär parsen, um Header zu finden
                        const tempParsedLines = lines.map(line => {
                            // Versuche, das Trennzeichen zu bestimmen (Komma oder Semikolon)
                            let separator = ',';
                            if (line.includes(';')) { // Heuristik: Semikolon ist oft in DE-CSVs
                                separator = ';';
                            }
                            return line.split(separator).map(cell => cell.trim().replace(/^"|"$/g, '')); // Entferne Anführungszeichen
                        });


                        for (let i = 0; i < Math.min(tempParsedLines.length, MAX_HEADER_SCAN_ROWS); i++) {
                            const row = tempParsedLines[i];
                            const filledCellsInRow = row.filter(cell => filledCell(cell)).length;
                            if (filledCellsInRow > maxFilledCells) {
                                maxFilledCells = filledCellsInRow;
                                headerRowIndex = i;
                            }
                        }

                        if (headerRowIndex === -1) {
                            extractedData = [];
                            updateTable();
                            reject(new Error('Keine sinnvolle Kopfzeile in der CSV-Datei gefunden.'));
                            return;
                        }

                        // Normalisiere Header-Namen
                        const rawHeaders = tempParsedLines[headerRowIndex].map(h => String(h || '').trim());
                        const normalizedHeaders = rawHeaders.map(h => 
                            h.toLowerCase().replace(/[^a-z0-9]/g, '')
                        );

                        const dataRows = tempParsedLines.slice(headerRowIndex + 1);

                        const mappedData = dataRows.map(row => {
                            const item = { ean: '', product: '', quantity: '0', details: [] };
                            let foundEAN = false;
                            let foundProduct = false;
                            let foundQuantity = false;

                            normalizedHeaders.forEach((normalizedHeader, index) => {
                                const value = row[index] !== undefined ? String(row[index]).trim() : '';

                                if ((normalizedHeader.includes('ean') || normalizedHeader.includes('barcode')) && !foundEAN) {
                                    item.ean = value;
                                    foundEAN = true;
                                } else if ((normalizedHeader.includes('produkt') || normalizedHeader.includes('bezeichnung') || normalizedHeader.includes('artikel')) && !foundProduct) {
                                    item.product = value;
                                    foundProduct = true;
                                } else if ((normalizedHeader.includes('menge') || normalizedHeader.includes('anzahl')) && !foundQuantity) {
                                    item.quantity = value.replace(/[^0-9.,]/g, '').replace(',', '.');
                                    if (isNaN(parseFloat(item.quantity))) {
                                        item.quantity = '0';
                                    }
                                    foundQuantity = true;
                                } else if (value && value !== '' && !item.details.includes(`${rawHeaders[index]}: ${value}`)) {
                                    item.details.push(`${rawHeaders[index]}: ${value}`);
                                }
                            });

                            item.ean = item.ean || '';
                            item.product = item.product || '';
                            item.quantity = item.quantity || '0';
                            item.details = item.details.join(', ');
                            item.scanned = 0;
                            return item;
                        }).filter(item => item.ean || item.product || parseInt(item.quantity) > 0);

                        extractedData = mappedData;
                        extractedData = consolidateData(extractedData);
                        console.log('Extracted CSV data:', extractedData);
                        if (!extractedData.length) {
                            displayFeedback('Keine relevanten Daten aus CSV extrahiert. Überprüfen Sie das Dateiformat, die Kopfzeilen (EAN, Produkt, Menge) und den Inhalt.', 'feedback-error');
                        } else {
                            displayFeedback(`Erfolgreich ${extractedData.length} Einträge aus CSV geladen.`, 'feedback-success');
                        }
                        updateTable();
                        resolve();
                    } catch (error) {
                        reject(new Error(`Fehler beim Parsen der CSV-Datei: ${error.message}`));
                    }
                };
                reader.onerror = (error) => reject(new Error(`Fehler beim Lesen der CSV-Datei: ${error}`));
                reader.readAsText(file);
            });
        }


        async function analyzeDocument(file) {
            try {
                // PDF-Text extrahieren
                const pdfText = await extractTextFromPDF(file);

                // API-Anfrage
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'llama-3.3-70b-versatile',
                        messages: [
                            {
                                role: 'system',
                                content: `Du bist ein Assistent, der Daten aus Lieferscheinen und Auftragsbestätigungen extrahiert. Analysiere den folgenden Text und extrahiere alle Tabellenzeilen mit den Feldern EAN, Produkt, Menge und Details. Gib die Daten in einer JSON-Liste zurück im Format: { "result": [{ "ean": "", "product": "", "quantity": "", "details": "" }, ...] }.

- EAN: Extrahiere die EAN, falls vorhanden (z.B. "6921727073747"). Wenn keine EAN angegeben ist, setze "".
- Produkt: Extrahiere die Artikelbezeichnung (z.B. "Hisense RS 818 N4 TIC *C* Side by Side Inox-Optik"). Wenn leer oder nicht vorhanden, setze "".
- Menge: Extrahiere die Zahl der Menge (z.B. "1" aus "1 Stck"). Entferne Einheiten wie "Stck" oder "Stück".
- Details: Kombiniere zusätzliche Informationen wie Artikelnummer, Einzelpreis, Gesamtpreis, Merkmale oder andere Angaben als durch Kommas getrennte Werte (z.B. "Artikelnr.: 57966, Einzelpreis: 599,99, Gesamtpreis: 599,99, Merkmale: 179,5 cm, Wassertank").
- Ignoriere Kopf- und Fußzeilen (z.B. Firmeninformationen, Bankverbindungen, Adressen, Zwischensummen) und fokussiere dich ausschließlich auf Tabellenzeilen, die mit "Pos." beginnen.
- Beispiel: "Pos. 1 Artikelnr. 57966 Hisense RS 818 N4 TIC *C* Side by Side Inox-Optik - H2 / H3 / H4 / H1 - 1 04.06.2025 1 Stck 599,99 599,99 1 179,5 cm - Wassertank - 20011698 6921727073747" → {"ean": "6921727073747", "product": "Hisense RS 818 N4 TIC *C* Side by Side Inox-Optik", "quantity": "1", "details": "Artikelnr.: 57966, Einzelpreis: 599,99, Gesamtpreis: 599,99, Merkmale: H2 / H3 / H4 / H1, 179,5 cm, Wassertank, Artikelnr.: 20011698"}.
- Wenn keine Tabellenzeilen gefunden werden, gib ein leeres Array zurück: { "result": [] }.
- Stelle sicher, dass jede Tabellenzeile ein separates JSON-Objekt in der Liste ist.`
                            },
                            {
                                role: 'user',
                                content: pdfText
                            }
                        ],
                        response_format: { type: 'json_object' }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API-Anfrage fehlgeschlagen: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
                }

                const result = await response.json();
                console.log('API-Antwort (roh):', JSON.stringify(result, null, 2));
                console.log('API-Antwort (content):', result.choices?.[0]?.message?.content);
                let data = [];
                try {
                    const content = result.choices?.[0]?.message?.content;
                    if (!content) {
                        throw new Error('Keine Inhalte in der API-Antwort gefunden.');
                    }
                    data = typeof content === 'string' ? JSON.parse(content) : content;
                    extractedData = Array.isArray(data.result) ? data.result : (Array.isArray(data) ? data : []);
                    // Initialisiere scanned-Zähler für jede Position
                    extractedData.forEach(item => {
                        item.scanned = 0;
                    });
                    extractedData = consolidateData(extractedData);
                } catch (error) {
                    throw new Error(`Fehler beim Parsen der API-Antwort: ${error.message}`);
                }

                console.log('Extrahierte Daten:', extractedData);
                if (!extractedData.length) {
                    displayFeedback('Keine Daten extrahiert. Überprüfen Sie den PDF-Inhalt oder die API-Antwort.', 'feedback-error');
                }
                updateTable();

            } catch (error) {
                console.error('Fehler bei der API-Analyse:', error);
                displayFeedback(`Fehler bei der Dokumentenanalyse: ${error.message}`, 'feedback-error');
                // Verstecke Ladebalken bei Fehler
                document.getElementById('loadingBar').classList.add('hidden');
            }
        }

        function scanEAN() {
            const ean = document.getElementById('eanInput').value.trim();
            const eanRegex = /^\d{13}$/; // Simplified EAN validation for common 13-digit EANs
            if (!eanRegex.test(ean)) {
                displayFeedback('Ungültige EAN. Bitte geben Sie eine 13-stellige Zahl ein.', 'feedback-error');
                playBeep(300, 0.2, 'square'); // Fallback: Synthetischer negativer Ton
                negativeTone.play().catch(error => { // Fallback bei MP3-Fehler
                    console.error('Fehler beim Abspielen des negativen Tons:', error);
                    playBeep(300, 0.2, 'square');
                });
                return;
            }

            const item = extractedData.find(item => item.ean === ean);
            if (item) {
                item.scanned = (item.scanned || 0) + 1;
                displayFeedback(`EAN ${ean} erfolgreich gescannt.`, 'feedback-success');
                playBeep(600, 0.2, 'sine'); // Fallback: Synthetischer positiver Ton
                positiveTone.play().catch(error => { // Fallback bei MP3-Fehler
                    console.error('Fehler beim Abspielen des positiven Tons:', error);
                    playBeep(600, 0.2, 'sine');
                });
                updateTable();
                setTimeout(() => {
                    const rowElements = document.querySelectorAll('#dataTableBody tr');
                    rowElements.forEach(row => {
                        if (row.children[0].textContent === ean) {
                            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            row.classList.add('ring', 'ring-4', 'ring-[#93c01f]');
                            setTimeout(() => row.classList.remove('ring', 'ring-4', 'ring-[#93c01f]'), 2000);
                        }
                    });
                }, 100);

            } else {
                unknownEANs.push(ean);
                displayFeedback(`EAN ${ean} nicht in der Liste gefunden.`, 'feedback-error');
                playBeep(300, 0.2, 'square'); // Fallback: Synthetischer negativer Ton
                negativeTone.play().catch(error => { // Fallback bei MP3-Fehler
                    console.error('Fehler beim Abspielen des negativen Tons:', error);
                    playBeep(300, 0.2, 'square');
                });
                updateUnknownEANs();
            }
            document.getElementById('eanInput').value = '';
        }

        function decreaseScanned(ean) {
            const item = extractedData.find(item => item.ean === ean);
            if (item && item.scanned > 0) {
                item.scanned--;
                updateTable();
            }
        }

        function increaseScanned(ean) {
            const item = extractedData.find(item => item.ean === ean);
            if (item) {
                item.scanned++;
                updateTable();
            }
        }

        function toggleEditEAN() {
            isEditingEAN = !isEditingEAN;
            const editButton = document.getElementById('editEANButton');
            if (isEditingEAN) {
                editButton.textContent = 'EAN bearbeiten (Aktiviert)';
                editButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                editButton.classList.add('bg-green-600', 'hover:bg-green-700');
                displayFeedback('EAN-Bearbeitungsmodus aktiviert. Klicken Sie auf eine EAN-Zelle, um sie zu bearbeiten.', 'feedback-success');
            } else {
                editButton.textContent = 'EAN bearbeiten (Deaktiviert)';
                editButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                editButton.classList.add('bg-gray-600', 'hover:bg-gray-700');
                displayFeedback('EAN-Bearbeitungsmodus deaktiviert.', 'feedback-success');
            }
            updateTable(); // Tabelle neu rendern, um Bearbeitungszustand anzuwenden
        }

        function saveEditedEAN(oldEAN, newEANElement) {
            const newEAN = newEANElement.textContent.trim();
            const eanRegex = /^\d{13}$/; // Simplified EAN validation

            if (newEAN === oldEAN) {
                // No change, just re-render to remove focus styles if any
                updateTable();
                return;
            }

            if (!eanRegex.test(newEAN)) {
                displayFeedback('Ungültige EAN. Bitte geben Sie eine 13-stellige Zahl ein.', 'feedback-error');
                newEANElement.textContent = oldEAN; // Revert to old EAN
                newEANElement.focus(); // Keep focus to allow correction
                return;
            }

            // Check if the new EAN already exists for another item
            const existingItem = extractedData.find(item => item.ean === newEAN && item.ean !== oldEAN);
            if (existingItem) {
                displayFeedback(`EAN ${newEAN} existiert bereits für ein anderes Produkt.`, 'feedback-error');
                newEANElement.textContent = oldEAN; // Revert to old EAN
                newEANElement.focus(); // Keep focus to allow correction
                return;
            }

            const itemToUpdate = extractedData.find(item => item.ean === oldEAN);
            if (itemToUpdate) {
                itemToUpdate.ean = newEAN;
                displayFeedback(`EAN von ${oldEAN} auf ${newEAN} geändert.`, 'feedback-success');
            }
            updateTable(); // Tabelle neu rendern, um die Änderung zu reflektieren
        }

        function updateTable() {
            const tbody = document.getElementById('dataTableBody');
            tbody.innerHTML = '';
            if (!extractedData.length) {
                displayFeedback('Keine Daten extrahiert.', 'feedback-error');
                return;
            }
            extractedData.forEach(item => {
                const row = document.createElement('tr');
                // Farbliche Hervorhebung: Grün nur bei scanned === quantity, Orange bei scanned > quantity
                const quantity = parseInt(item.quantity) || 0;
                const scanned = item.scanned || 0;
                if (scanned > 0) {
                    if (scanned === quantity) {
                        row.classList.add('highlight-green');
                    } else if (scanned > quantity) {
                        row.classList.add('highlight-orange');
                    }
                }
                const eanCellContent = isEditingEAN
                    ? `<span contenteditable="true" class="editable-ean" onblur="saveEditedEAN('${item.ean}', this)">${item.ean || ''}</span>`
                    : `${item.ean || ''}`;

                row.innerHTML = `
                    <td class="border border-gray-300 p-3 text-sm">${eanCellContent}</td>
                    <td class="border border-gray-300 p-3 text-sm">${item.product || ''}</td>
                    <td class="border border-gray-300 p-3 text-sm">${item.quantity || ''}</td>
                    <td class="border border-gray-300 p-3 text-sm">
                        <div class="scanned-controls">
                            <button onclick="decreaseScanned('${item.ean}')">-</button>
                            <span id="scannedCount-${item.ean}">${item.scanned || 0}</span>
                            <button onclick="increaseScanned('${item.ean}')">+</button>
                        </div>
                    </td>
                    <td class="border border-gray-300 p-3 text-sm">${item.details || ''}</td>
                `;
                tbody.appendChild(row);
            });
            updateUnknownEANs();
            const allScanned = extractedData.length > 0 && extractedData.every(item => parseInt(item.scanned) === parseInt(item.quantity));
            document.body.style.backgroundColor = allScanned ? '#d4edda' : '';
        }

        function updateUnknownEANs() {
            const unknownEANsDiv = document.getElementById('unknownEANs');
            if (unknownEANs.length > 0) {
                unknownEANsDiv.innerHTML = `<p class="text-sm font-medium text-gray-700">Unbekannte EANs: ${unknownEANs.join(', ')}</p>`;
            } else {
                unknownEANsDiv.innerHTML = '';
            }
        }

        function exportToExcel() {
            if (!extractedData.length) {
                displayFeedback('Keine Daten zum Exportieren vorhanden.', 'feedback-error');
                return;
            }
            const data = extractedData.map(item => ({
                EAN: item.ean,
                Produkt: item.product,
                Menge: item.quantity,
                'Gescannte EANs': item.scanned || 0,
                Details: item.details
            }));
            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Lager');
            XLSX.writeFile(wb, 'lager_export.xlsx');
        }

        function exportToCSV() {
            if (!extractedData.length) {
                displayFeedback('Keine Daten zum Exportieren vorhanden.', 'feedback-error');
                return;
            }
            const headers = ['EAN,Produkt,Menge,Gescannte EANs,Details'];
            const rows = extractedData.map(item => 
                `${item.ean || ''},${item.product || ''},${item.quantity || ''},${item.scanned || 0},${item.details || ''}`
            );
            const csv = [...headers, ...rows].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lager_export.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        function displayFeedback(message, type) {
            const feedbackDiv = document.getElementById('feedbackMessage');
            feedbackDiv.innerHTML = `<p class="text-sm ${type}">${message}</p>`;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target === modal) {
                closeSettingsModal();
            }
        };
    </script>
</body>
</html>
